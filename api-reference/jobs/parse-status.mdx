---
title: "Get Parse Job Status"
openapi: "/api-reference/openapi.json GET /parse/{job_id}"
description: "Check the status and retrieve results of parsing jobs"
---

## Overview

The Get Parse Job Status endpoint allows you to check the current status of parsing jobs and retrieve the complete results when processing is complete. This endpoint is specifically designed for the parsing API and returns comprehensive document analysis including text extraction, image recognition, table parsing, and OCR data.

<Note>
Parsing jobs are processed asynchronously. Use this endpoint to poll for completion and retrieve results when the job status is "Succeeded".
</Note>

## Response

<ResponseField name="job_id" type="string">
  Unique identifier for the parsing job
</ResponseField>

<ResponseField name="status" type="string">
  Current job status: "Starting", "Processing", "Succeeded", or "Failed"
</ResponseField>

<ResponseField name="created_at" type="string">
  Timestamp when the job was created
</ResponseField>

<ResponseField name="started_at" type="string">
  Timestamp when processing started (only present when status is not "Starting")
</ResponseField>

<ResponseField name="finished_at" type="string">
  Timestamp when processing completed (only present when status is "Succeeded" or "Failed")
</ResponseField>


<ResponseField name="total_chunks" type="number">
  Number of chunks in the document (only present when status is "Succeeded")
</ResponseField>

<ResponseField name="chunks" type="array">
  Array of document chunks with detailed analysis (only present when status is "Succeeded")
</ResponseField>

<RequestExample>

```bash cURL
curl -X 'GET' \
  'https://prod.visionapi.unsiloed.ai/parse/04a7a6d8-5ef7-465a-b22a-8a98e7104dd9' \
  -H 'accept: application/json' \
  -H 'api-key: your-api-key'
```

```python Python
import requests
import time

def get_parse_job_status(job_id, api_key):
    """Get the status of a parsing job"""
    
    url = f"https://prod.visionapi.unsiloed.ai/parse/{job_id}"
    headers = {"api-key": api_key}
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        job = response.json()
        print(f"Job Status: {job['status']}")
        print(f"Created: {job['created_at']}")
        
        if job['status'] == 'Succeeded':
            print("Job completed successfully!")
            print(f"Total chunks: {job['total_chunks']}")
            return job
        elif job['status'] == 'Failed':
            print(f"Job failed: {job.get('message', 'Unknown error')}")
            return None
        elif job['status'] in ['Starting', 'Processing']:
            print("Job is currently being processed...")
            return job
    else:
        print("Error:", response.status_code, response.text)
        return None

# Usage
job_id = "04a7a6d8-5ef7-465a-b22a-8a98e7104dd9"
result = get_parse_job_status(job_id, "your-api-key")
```

```javascript JavaScript
async function getParseJobStatus(jobId, apiKey) {
  const response = await fetch(`https://prod.visionapi.unsiloed.ai/parse/${jobId}`, {
    headers: {
      'accept': 'application/json',
      'api-key': apiKey
    }
  });

  if (response.ok) {
    const job = await response.json();
    console.log('Job Status:', job.status);
    console.log('Created:', job.created_at);
    
    switch (job.status) {
      case 'Succeeded':
        console.log('Job completed successfully!');
        console.log('Total chunks:', job.total_chunks);
        return job;
      case 'Failed':
        console.log('Job failed:', job.message || 'Unknown error');
        return null;
      case 'Starting':
      case 'Processing':
        console.log('Job is currently being processed...');
        return job;
      default:
        console.log('Unknown status:', job.status);
        return job;
    }
  } else {
    console.error('Failed to get job status:', await response.text());
    return null;
  }
}

// Usage
const jobId = '04a7a6d8-5ef7-465a-b22a-8a98e7104dd9';
const result = await getParseJobStatus(jobId, 'your-api-key');
```

</RequestExample>

<ResponseExample>

```json Starting Job
{
  "job_id": "04a7a6d8-5ef7-465a-b22a-8a98e7104dd9",
  "status": "Starting",
  "created_at": "2025-10-22T06:51:16.870302Z"
}
```

```json Processing Job
{
  "job_id": "04a7a6d8-5ef7-465a-b22a-8a98e7104dd9",
  "status": "Processing",
  "created_at": "2025-10-22T06:51:16.870302Z",
  "started_at": "2025-10-22T06:51:16.966136Z"
}
```

```json Succeeded Job
{
  "job_id": "04a7a6d8-5ef7-465a-b22a-8a98e7104dd9",
  "status": "Succeeded",
  "created_at": "2025-10-22T06:51:16.870302Z",
  "started_at": "2025-10-22T06:51:16.966136Z",
  "finished_at": "2025-10-22T06:57:19.821541Z",
  "total_chunks": 25,
  "chunks": [
    {
      "segments": [
        {
          "segment_type": "Picture",
          "content": "eternal",
          "image": "https://s3.us-east-1.amazonaws.com/unsiloed-bucket/...",
          "page_number": 1,
          "segment_id": "1c60ecbd-b6da-493c-b3f6-6849337a981f",
          "confidence": 0.6062846,
          "page_width": 1191.0,
          "page_height": 1684.0,
          "html": "<p>The image displays a logo...</p>",
          "markdown": "Eternal Logo\n\nThe image displays a logo...",
          "bbox": {
            "left": 72.92226,
            "top": 62.030334,
            "width": 230.36308,
            "height": 55.395317
          },
          "ocr": [
            {
              "bbox": {
                "left": 63.753525,
                "top": 5.395447,
                "width": 164.45312,
                "height": 42.757812
              },
              "text": "eternal",
              "confidence": 0.9999992
            }
          ]
        }
      ]
    }
  ]
}
```

```json Failed Job
{
  "job_id": "04a7a6d8-5ef7-465a-b22a-8a98e7104dd9",
  "status": "Failed",
  "created_at": "2025-10-22T06:51:16.870302Z",
  "started_at": "2025-10-22T06:51:16.966136Z",
  "finished_at": "2025-10-22T06:51:25.123456Z",
  "message": "Failed to process document: File appears to be corrupted"
}
```

```json Error Response - Job Not Found
{
  "detail": "Job 04a7a6d8-5ef7-465a-b22a-8a98e7104dd9 not found"
}
```

```json Error Response - Invalid API Key
{
  "detail": "Invalid API key"
}
```

</ResponseExample>

## Job Status Values

<AccordionGroup>
  <Accordion title="Starting">
    Job has been created and is waiting to be processed. This is the initial status when a parsing job is first created.
  </Accordion>

  <Accordion title="Processing">
    Job is currently being processed. This includes PDF parsing, text extraction, image analysis, table detection, and OCR processing.
  </Accordion>

  <Accordion title="Succeeded">
    Job has completed successfully. The response includes the complete analysis results with all extracted data, images, and metadata.
  </Accordion>

  <Accordion title="Failed">
    Job failed during processing. Check the message field for details about what went wrong.
  </Accordion>
</AccordionGroup>

## Polling Strategy

For long-running parsing jobs, implement a polling strategy to check status periodically:

```python
import requests
import time

def poll_parse_job(job_id, api_key, max_wait_time=300, poll_interval=5):
    """Poll a parsing job until completion or timeout"""
    
    start_time = time.time()
    headers = {"api-key": api_key}
    
    while time.time() - start_time < max_wait_time:
        response = requests.get(
            f"https://prod.visionapi.unsiloed.ai/parse/{job_id}",
            headers=headers
        )
        
        if response.status_code == 200:
            job = response.json()
            
            if job['status'] == 'Succeeded':
                return job
            elif job['status'] == 'Failed':
                raise Exception(f"Job failed: {job.get('message', 'Unknown error')}")
            elif job['status'] in ['Starting', 'Processing']:
                print(f"Job status: {job['status']} - waiting...")
                time.sleep(poll_interval)
            else:
                print(f"Unknown status: {job['status']}")
                time.sleep(poll_interval)
        else:
            print(f"Error checking status: {response.status_code}")
            time.sleep(poll_interval)
    
    raise Exception("Job polling timed out")

# Usage
try:
    result = poll_parse_job("04a7a6d8-5ef7-465a-b22a-8a98e7104dd9", "your-api-key")
    print("Job completed successfully!")
    print(f"Total chunks: {result['total_chunks']}")
except Exception as e:
    print(f"Error: {e}")
```

## Segment Types

When a job succeeds, the response includes detailed analysis of different document segments:

### Picture
Images and graphics within the document, including logos, charts, and illustrations.

### SectionHeader
Document headers and titles that define section boundaries.

### Text
Regular text content including paragraphs, sentences, and individual text elements.

### Table
Tabular data with structured rows and columns.

### Caption
Text captions associated with images or figures.

Each segment includes:
- **segment_type**: Type of content detected
- **content**: Extracted text content
- **image**: URL to extracted image (if applicable)
- **page_number**: Page where the segment appears
- **confidence**: Confidence score for the extraction
- **bbox**: Precise coordinates of the segment
- **html**: HTML-formatted content
- **markdown**: Markdown-formatted content
- **ocr**: Detailed OCR data with individual text elements

## Error Handling

### Common Error Scenarios

1. **Job Not Found**: Invalid or expired job ID
2. **Invalid API Key**: Authentication failed
3. **Processing Timeout**: Job took too long to complete
4. **Server Error**: Internal processing error

### Best Practices

- **Polling Frequency**: Check status every 5-10 seconds for long-running jobs
- **Timeout Handling**: Implement reasonable timeouts to prevent infinite polling
- **Error Recovery**: Handle failed jobs gracefully with retry logic
- **API Key Security**: Keep your API key secure and never expose it in client-side code

## Rate Limits

- **Status Checks**: Rate limits apply to prevent abuse
- **Concurrent Jobs**: Limited number of active parsing jobs per API key
- **Request Frequency**: Avoid excessive polling (recommended: 5-10 second intervals)

Check your API plan for specific limits and quotas. 